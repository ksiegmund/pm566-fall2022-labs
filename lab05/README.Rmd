---
title: "Lab 05"
author: "ks"
date: "`r Sys.Date()`"
output: github_document
always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r install-libraries}
library(lubridate)
library(tidyverse)
library(data.table)
library(dtplyr)
```


## Step 1. Read in the data
First download and then read in with data.table:fread()

```{r read-data, cache=TRUE}
if (!file.exists("../lab03/met_all.gz")) {
  download.file("https://raw.githubusercontent.com/USCbiostats/data-science-data/master/02_met/met_all.gz", 
                "met_all.gz", method="libcurl", timeout = 60)  
}

met <- data.table::fread("../lab03/met_all.gz")
```

Remove temperatures less than -17C and change elev 9999 to missing value code.
```{r remove-low-temp}
met <- met[temp > -17][elev == 9999.0, elev := NA]
```



Read in the stations data:
```{r stations, cache = TRUE}
# Download the data
stations <- fread("ftp://ftp.ncdc.noaa.gov/pub/data/noaa/isd-history.csv")
stations[, USAF := as.integer(USAF)]

# Dealing with NAs and 999999
stations[, USAF   := fifelse(USAF == 999999, NA_integer_, USAF)]
stations[, CTRY   := fifelse(CTRY == "", NA_character_, CTRY)]
stations[, STATE  := fifelse(STATE == "", NA_character_, STATE)]

# Selecting the three relevant columns, and keeping unique records
stations <- unique(stations[, list(USAF, CTRY, STATE)])

# Dropping NAs
stations <- stations[!is.na(USAF)]

# Removing duplicates
stations[, n := 1:.N, by = .(USAF)]
stations <- stations[n == 1,][, n := NULL]
```

Merge met data with stations.
```{r merge-datatables}
met <-  
  merge(
  # Data
  x     = met,      
  y     = stations, 
  # List of variables to match
  by.x  = "USAFID",
  by.y  = "USAF", 
  # Which obs to keep?
  all.x = TRUE,      
  all.y = FALSE
  ) 

nrow(met)
```

# Question 1: Representative station for the US

Compute mean temperature, wind speed and atmospheric pressure for each weather station, and pick the weather station with the average value closest to the median for the US.

```{r}
station_averages <- 
     met[ , .(
       temp      = mean(temp, na.rm=T),
       wind.sp   = mean(wind.sp, na.rm=T),
       atm.press = mean(atm.press,na.rm=T)
     ), by = USAFID]
```

The above computes the mean by weather station.
Now let's compute the median value for each variable.

```{r}
stmeds <- station_averages[ , .(
          temp50     = median(temp, na.rm=T),
          windsp50   = median(wind.sp,na.rm=T),
          atmpress50 = median(atm.press,na.rm=T)
)]
stmeds
```

A helpful function we might want to use 'which.min()'.

```{r}
station_averages[ , 
              temp_dist50 := abs(temp - stmeds$temp50)][order(temp_dist50)]
```

Let's use which.min
```{r}
station_averages[ which.min(temp_dist50)]
```

It matches the result above.

# Question 2: Representative station per state

Just like the previous question, you are asked to identify what is the most representative, the median, station per state. This time, instead of looking at one variable at a time, look at the euclidean distance. If multiple stations show in the median, select the one located at the lowest latitude.

```{r}
station_averages <- 
     met[ , .(
       temp      = mean(temp, na.rm=T),
       wind.sp   = mean(wind.sp, na.rm=T),
       atm.press = mean(atm.press,na.rm=T)
     ), by = .(USAFID,STATE)]
head(station_averages)
```

```{r}
statemeds<- station_averages[ , .(
           temp50    = median(temp, na.rm=T), 
           wind.sp50 = median(wind.sp, na.rm=T)
            ), by = STATE]
statemeds
```

```{r}
station_averages <- 
  merge(
  x = station_averages,
  y = statemeds,
  by.x = "STATE",
  by.y = "STATE",
  all.x = TRUE,
  all.y = FALSE
)
```



```{r}
station_averages[ , temp_dist_state50   := temp - temp50]
station_averages[ , windsp_dist_state50 := wind.sp - wind.sp50] 
station_averages
```

```{r}
station_averages[ , eucdist := temp_dist_state50^2 +
                                windsp_dist_state50^2]
```


```{r }
repstation <- station_averages[ , .(
                    eucdist = min(eucdist, na.rm=T))
                  , by=STATE]
```

Now I'll find the station with the lowest Euclidean distance to the median temperature and wind speed by merging these minimum distances back with the station names, and only saving the records that include the minimum Euclidean distance.

(I should go back and add atmospheric pressure to answer the question completely, but this shows the steps to follow.)

```{r}
merge(
  x = station_averages,
  y = repstation,
  by.x = c("eucdist","STATE"),
  by.y = c("eucdist","STATE"),
  all.x = FALSE,
  all.y = TRUE
)
```

Phew! We found the stations with temperture and wind speed closest in Euclidean distance to the median temp and median wind speed in the state.

Going back to read the directions once more, I realize I was supposed to use quantile() function instead of median().  The median is the 0.5 quantile or 50th percentile. We call it like this:

```{r}
x <- c(1:5, NA)
quantile(x, probs=0.5, na.rm=TRUE)
```

## Question 3


## Question 4: Means of means
Using the quantile() function, generate a summary table that shows the number of states included, average temperature, wind-speed, and atmospheric pressure by the variable “average temperature level,” which you’ll need to create.

Start by computing the states’ average temperature. Use that measurement to classify them according to the following criteria:

low: temp < 20
Mid: temp >= 20 and temp < 25
High: temp >= 25


```{r}
met[, state_temp := mean(temp, na.rm = TRUE), by = STATE]
met[, temp_cat := fifelse(
  state_temp < 20, "low-temp", 
  fifelse(state_temp < 25, "mid-temp", "high-temp"))
  ]
head(met)
```

Let's make sure that we don't have NAs

```{r}
table(met$temp_cat, useNA = "always")
```

Now, let's summarize.  (Not sure why the direction said to use the quantile function for this!)

```{r}
tab <- met[, .(
  N_entries   = .N,
  N_stations  = length(unique(USAFID)),
  N_states    = length(unique(STATE)),
  avg_temp    = mean(temp, na.rm = TRUE),
  avg_wind.sp = mean(wind.sp, na.rm = TRUE),
  avg_atm.pre = mean(atm.press, na.rm = TRUE)
), by = temp_cat]

knitr::kable(tab)
```

Note the call to the function kable() to make a 'pretty table' in markdown.
